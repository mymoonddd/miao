<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MyRegExp-Graph</title>
  <style>
    /* * {
      background-color: rgba(0,0,0,0.08);
      box-shadow: inset 0 0 1px red;
    } */

    body {
      background-color: #c8e0e4;
    }
    #userInput {
      width: 70%;
      margin: auto;
      margin-top: 50px;
    }
    input {
      width: 76%;
      margin: 0;
      height: 50px;
      padding-left: 12px;
    }
    button {
      width: 20%;
      margin: 0;
      margin-left: 10px;
      height: 54px;
      white-space: nowrap;
      text-overflow: clip;
    }
    #resultPre {
      width: 70%;
      margin: auto;
      margin-top: 50px;
      overflow-x: scroll;
      border: 1px solid black;
      background-color: #fff;
    }

    #info {
      width: 70%;
      margin: auto;
      background-color: lightgreen;
    }


  </style>
</head>
<body>
  <div id="userInput">
    <label><input type="text" id="regInput" placeholder="请输入正则表达式" ></label><button id="regInputButton">绘制铁路图</button>
  </div>
  <div id="resultPre">
    <svg></svg>
  </div>
  <div id = 'info'>
      <p>还未支持的语法：[a-b] ^ & 转义符\ </p>
  </div>
</body>
  <script>

    regInput.addEventListener('input', draw)
    regInputButton.addEventListener('click',draw)
    
    function draw() {
      let svg = document.querySelector('svg')
      svg.innerHTML = ''
      let input = regInput.value
      let regNode = parseRegularExpression(input)
      let graph = createRegularExpressionGraph(regNode)
      svg.setAttribute('width', graph.width)
      svg.setAttribute('height', graph.height)
    }

    // 将字符串解析为正则表达式
    var i = 0
    var str
    var groupIndex = 1

    function parsePart() {
      if (str[i] == '[') {
        return parseCharacterClass()
      }
      if (str[i] == '*' || str[i] == '?' || str[i] == '+' || str[i] == '{') {
        return parseQuantifier()
      }
      if (str[i] == '(') {
        return parseCaptureGroup()
      }
      if (str[i] == '\\') {
        return parseEscape()
      }
      return parseCharacter()
    }

    function parseCharacter() {
      let node = {
        type: 'Character',
        start: i,
        end: i + 1,
        raw: str[i],
        value: str[i],
      }
      i++
      return node
    }

    function parseCharacterClass() {
      let node = {
        type: 'CharacterClass',
        start: i,
        end: 1,
        raw: '',
        revert: false,
        elements:[]
      }
      i++ //skip [
      if (str[i] == '^') {
        node.revert = true
      }
      while (str[i] != ']' && str[i] !== undefined) {
        let char = parseCharacter()
        if (str[i] == '-') {
          i++
          if (str[i] == ']') {
            node.elements.push(char)
            i--
            char = parseCharacter()
            node.elements.push(char)
            break
          } else {
            let char2 =  parseCharacter()
            let rangeNode = {
              type: 'CharacterRange',
              start: char.start,
              startCharacter: char.value,
              end: char2.end,
              endCharacter: char2.value,
              raw: str.slice(char.start, char2.end),
            }
            node.elements.push(rangeNode)
          }
        } else {
          node.elements.push(char)
        }
      }
      i++ // skip ]
      node.end = i
      node.raw = str.slice(node.start, node.end)
      return node
    }

    function parseQuantifier() {
      let node = {
        type: 'Quantifier',
        start: i,
        end: 1,
        raw: '',
        min: 0,
        max: 1,
        element: null, //放重复的内容
        greedy: true,
      }
      if (str[i] == '*') {
        node.max = Infinity
        i++
      } else if (str[i] == '?') {
        i++
      } else if (str[i] == '+') {
        i++
        node.min = 1
        node.max = Infinity
      } else {
        i++ // skip {
        node.min = parseInteger()
        if (str[i] == '}') {
          node.max = node.min
        } else {
          i++ // skip .
          if (str[i] == '}') {
            node.max = Infinity
          } else {
            node.max =  parseInteger()
          }
        }
        i++ //skip}
      }

      if (str[i] == '?') {
        node.greedy = false
        i++
      }
      node.end = i
      node.raw = str.slice(node.start, node.end)
      return node
    }

    function parseInteger() {
      let numStr = ''
      while (str[i] <= '9' && str[i] >= '0') {
        numStr += str[i]
        i++
      }
      return parseInt(numStr)
    }

    function parseBranch() {
      let node = {
        type: 'Branch',
        start: i,
        end: 1,
        raw: '',
        elements: [],
      }
      while (true) {
        let part = parsePart()
        if (part.type == 'Quantifier') {
          let prev = node.elements.pop()
          part = {
            type:'Quantifier',
            start: prev.start,
            end: part.end,
            raw: str.slice(prev.start, part.end),
            min: part.min,
            max: part.max,
            element: prev,
          }
        }
        node.elements.push(part)
        if (str[i] == '|' || str[i] == undefined || str[i] == ')' || str[i] == undefined) {
          break
        }
      }
      node.end = i
      node.raw = str.slice(node.start, node.end)
      return node
    }

    function parseBranches() {
      let nodes = []
      while (true) {
        if (str[i] == '|') {
          i++ // skip |
        } else {
          nodes.push(parseBranch())
        }
        if (str[i] == undefined || str[i] == ')') {
          break
        }
      }
      return nodes
    }

    function parseCaptureGroup() {
      let node = {
        type: 'CaptureGroup',
        start: i,
        end: 1,
        raw: '',
        groupIndex: 0,
        groupName: '',
        assertion: false,
        positive: true,
        lookahead: true,
        branches: [],
      }

      i++ //skip (
      if (str[i] == '?') {
        i++ // skip ?
        if (str[i] == ':') {                      // 非捕获分组
          i++ // skip :
        } else if (str[i] == '=') {               // 正向预测断言
          node.assertion = true
          node.lookahead = true
          node.positive = true
          i++ // skip =
        } else if (str[i] == '!') {               // 负向预测断言
          node.assertion = true
          node.lookahead = true
          node.positive = false
          i++ // skip !
        } else if (str[i] == '<') {               // 具名分组或回顾断言
          i++ // skip <
          if (str[i] == '=') {                        // 正向回顾断言
            node.assertion = true
            node.lookahead = false
            node.positive = true
            i++ // skip =
          } else if (str[i] == '!') {                // 负向回顾断言
            node.assertion = true
            node.lookahead = false
            node.positive = false
            i++ // skip !
          } else {                                    // 具名分组
            node.groupIndex = groupIndex++
            node.groupName = parseGroupName()
          }
        }
      } else {
        node.groupIndex = groupIndex++
      }
      if (str[i] !== ')') {
        node.branches = parseBranches()
      } else {
        node.end = node.start
      }

      i++ //skip )

      node.end = i
      node.raw = str.slice(node.start, node.end)
      return node
    }

    function parseGroupName() {
      let nameStr = ''
      while (str[i] !== '>' && str[i] !== undefined) {
        nameStr += str[i]
        i++
      }
      i++ //skip >
      return nameStr
    }

    function parseEscape() {
      let node = {
        type: 'Escape',
        start: i,
        end: 1,
        value: '',
        raw: '',
      }
      i++ // skip \
      if (str[i] == '\\') {
        i++ // skip \
        node.value = `\\${str[i]}`
      } else {
        node.value = str[i]
      }
      i++
      node.end = i
      node.raw = str.slice(node.start, node.end)
      return node
    }

    function parsePattern() {
      let node = {
        type: 'Regular Expresstion',
        branches: parseBranches(),
      }
      return node
    }

    function parseRegularExpression(input) {
      str = input
      i = 0
      groupIndex = 1
      return parsePattern()
    }

    //画图
    var gp = 10
    var svg = document.querySelector('svg')

    function elt(tagName, attrs = {}, ...children) {
      let el = document.createElementNS("http://www.w3.org/2000/svg", tagName)
      for (let key in attrs) {
        el.setAttribute(key, attrs[key])
      }
      for (let child of children) {
        if (typeof child == 'string') {
          child = document.createTextNode(child)
        }
        el.appendChild(child)
      }
      svg.appendChild(el)
      return el
    }

    function createGraph(node) {
      if (node.type == 'Character') {
        return createCharacterGraph(node)
      }
      if (node.type == 'CharacterClass') {
        return createCharacterClassGraph(node)
      }
      if (node.type == 'Branch') {
        return createBranchGraph(node)
      }
      if (node.type == 'CaptureGroup') {
        return createCaptureGroupGraph(node)
      }
      if (node.type == 'Quantifier') {
        return createQuantifierGraph(node)
      }
      if (node.type == 'Regular Expresstion') {
        return createRegularExpressionGraph(node)
      }
      return createBranchesGraph(node)

    }

    function add(x,y) {
      return x+y
    }
    function max(x,y) {
      return Math.max(x,y)
    }

    function createCharacterGraph(node) {
      let text = elt('text', {
        'dominant-baseline': 'text-before-edge',
        x: gp/2,
        y: gp/2,
        'color': 'white',
      }, node.value)
      let textBox = text.getBBox()
      let rect = elt('rect', {
        width: textBox.width + gp,
        height: textBox.height + gp,
        fill: '#dae9e5',
        rx: 10,
      })
      let g = elt('g', {}, rect, text)
      let gBox = g.getBBox()
      return {
        g,
        width: gBox.width,
        height: gBox.height,
      }
    }
    function createCharacterClassGraph(node) {
      let graphs = node.elements.map(createGraph)
      let height = graphs.map(it => it.height).reduce(add) + (graphs.length + 1) * gp
      let width = graphs.map(it => it.width).reduce(max) + 2 * gp
      let group = elt('rect', {
        height,
        width,
        fill: 'none'
      })
      let g = elt('g')
      g.appendChild(group)

      let move = gp
      graphs.forEach(graph => {
        graph.g.setAttribute('transform', `translate(${(width - graph.width) / 2}, ${move})`)
        g.appendChild(graph.g)
        let line = elt('path', {
          d : `
            M 0 ${height / 2}
            C ${gp/2} ${height / 2} ${gp/2} ${move + graph.height / 2} ${(width - graph.width) / 2} ${move + graph.height / 2}
            M ${width} ${height / 2}
            C ${width - gp/2} ${height / 2} ${width - gp/2} ${move + graph.height / 2} ${width - (width - graph.width) / 2} ${move + graph.height / 2}
          `,
          fill: 'none',
          stroke: 'black',
          'stroke-width': '2',
        })
        g.appendChild(line)
        move += graph.height + gp
      })


      let gBOX = g.getBBox()

      return {
        g,
        width: gBOX.width,
        height: gBOX.height
      }

    }
    function createBranchGraph(node) {
      let graphs = node.elements.map(createGraph)
      let width = graphs.map(it => it.width).reduce(add) + (graphs.length + 1) * gp
      let height = graphs.map(it => it.height).reduce(max) + 2 * gp
      let group = elt('rect', {
        width,
        height,
        fill: 'none'
      })
      let g = elt('g')
      g.appendChild(group)
      let move = gp

      graphs.forEach(graph => {
      graph.g.setAttribute('transform', `translate(${move}, ${(height - graph.height) / 2})`)
      let line = elt('line', {
        'stroke-width': 2,
        'x1': move - gp,
        'y1': height / 2,
        'x2': move,
        'y2': height / 2,
        'stroke': 'black',
        })
        g.appendChild(line)
        g.appendChild(graph.g)
        move += graph.width + gp
      })

      let line = elt('line', {
        'stroke-width': 2,
        'x1': move - gp,
        'y1': height / 2,
        'x2': move,
        'y2': height / 2,
        'stroke': 'black',
      })

      g.appendChild(line)

      let gBox = g.getBBox()
      return {
        g,
        width: gBox.width,
        height: gBox.height
      }
    }
    function createBranchesGraph(node) {
      let graphs = node.map(createGraph)
      let width = graphs.map(it => it.width).reduce(max) + 4 * gp
      let height = graphs.map(it => it.height).reduce(add) + (graphs.length + 1) * gp
      let group = elt('rect', {
        height,
        width,
        fill: 'none'
      })
      let g = elt('g')
      g.appendChild(group)

      let move = gp
      graphs.forEach(graph => {
        let x = (width - graph.width) / 2
        graph.g.setAttribute('transform', `translate(${x},${move})`)
        g.appendChild(graph.g)

        let y = move + graph.height / 2
        let line = elt('path', {
          d:`
            M ${x} ${y}
            H ${2*gp}
            C ${gp} ${y} ${gp} ${height / 2} ${0} ${height / 2}
            M ${width - x} ${y}
            H ${width - 2*gp}
            C ${width - gp} ${y} ${width - gp} ${height / 2} ${width} ${height / 2}
          `,
          fill: 'none',
          stroke: 'black',
          'stroke-width': '2',
        })
        g.appendChild(line)

        move += graph.height + gp
      })

      let gBox = g.getBBox()
      return {
        g,
        width: gBox.width,
        height: gBox.height,
      }
    }
    function createCaptureGroupGraph(node) {
      let graph = createGraph(node.branches)
      let group = elt('rect', {
        width: graph.width,
        height: graph.height + 2 * gp,
        fill: 'none',
      })
      graph.g.setAttribute('transform', `translate(0, ${gp})`)
      let g = elt('g')
      g.appendChild(group)
      g.appendChild(graph.g)

      if (node.groupIndex > 0) {         // 给捕获分组加虚框
        let dashBorder = elt('path', {
          d:`
            M 0 ${gp * 1.7}
            H ${graph.width}
            V ${graph.height}
            H 0
            V ${gp * 1.7}
          `,
          fill: 'none',
          stroke: 'grey',
          'stroke-width': '2',
          'stroke-dasharray':'10 5',
        })
        g.appendChild(dashBorder)

        let info = `Group #${node.groupIndex}` // 添加分组信息
        if (node.groupName !== '') {
          info += ' ' + node.groupName
        }
        let groupInfo = elt('text', {
          'dominant-baseline': 'text-before-edge',
          x: 0,
          y: 0,
          'style': 'color: white',
          'font-size': '12'
        }, info)
        g.appendChild(groupInfo)

        let infoBox = groupInfo.getBBox()
        if (infoBox.width > graph.width) {     // 分组名称超过虚框长度的话 补足右边缺少的连接线
          let fillLine = elt('path', {
            d: `
              M ${graph.width} ${(graph.height + 2 * gp) / 2}
              H ${infoBox.width}
            `,
            fill: 'none',
            stroke: 'black',
            'stroke-width': '2',
          })
          g.appendChild(fillLine)
        }
      }

      let gBox = g.getBBox()
      return {
        g,
        width: gBox.width,
        height: gBox.height,
      }
    }
    function createQuantifierGraph(node) {
      let graph = createGraph(node.element)
      let width =  graph.width + 4 * gp
      let height = graph.height + 4 * gp
      let group = elt('rect' ,{
        width,
        height,
        fill:'none',
      })
      let g = elt('g')
      g.appendChild(group)
      graph.g.setAttribute('transform', `translate(${2 * gp}, ${2 * gp})`)
      g.appendChild(graph.g)

      let line = elt('path', {
        d:`
        M ${2 * gp} ${height / 2}
        H 0
        M ${width - 2 * gp} ${height / 2}
        H ${width}
        `,
        fill: 'none',
        stroke: 'black',
        'stroke-width': '2',
      })
      g.appendChild(line)

      if (node.min == 0) {
        let skipLine = elt('path', {
          d: `
            M 0 ${height / 2}
            A ${gp} ${gp} 0 0 0 ${gp} ${height / 2 - gp}
            V ${2*gp}
            A ${gp} ${gp} 0 0 1 ${2*gp} ${gp}
            H ${width - 2 * gp}
            A ${gp} ${gp} 0 0 1 ${width - gp} ${2*gp}
            V ${height / 2 - gp}
            A ${gp} ${gp} 0 0 0 ${width} ${height / 2}
          `,
          fill: 'none',
          stroke: 'black',
          'stroke-width': '2',
        })
        g.appendChild(skipLine)
        let skipText = elt('text', {
          x:width / 2 - gp,
          y:0,
          fill:"black",
          'font-size': '12',
          'dominant-baseline': 'text-before-edge',
        },'skip~')
        g.appendChild(skipText)
      }
      if (node.max > 1) {
        let repeatLine = elt('path', {
          d: `
            M ${2 * gp} ${height / 2}
            A ${gp} ${gp} 0 0 0 ${gp} ${height / 2 + gp}
            V ${height - 2*gp}
            A ${gp} ${gp} 0 0 0 ${2 * gp} ${height - gp}
            H ${width - 2 * gp}
            A ${gp} ${gp} 0 0 0 ${width - gp} ${height - 2 * gp}
            V ${height / 2 + gp}
            A ${gp} ${gp} 0 0 0 ${width - 2 * gp} ${height / 2}
          `,
          fill: 'none',
          stroke: 'black',
          'stroke-width': '2',
        })
        g.appendChild(repeatLine)

        let repeatNum = ''                // 显示重复次数
        if (node.min  == node.max) {
          repeatNum = `repeat: ${node.min}`
        } else {
          repeatNum += `min: ${node.min} max: ${node.max}`
        }
        let repeatTimes = elt('text', {
          x:gp,
          y:height,
          fill:"black",
          'font-size': '12',
          'dominant-baseline': 'text-after-edge',
        }, repeatNum)
        g.appendChild(repeatTimes)
        let repTimesBox = repeatTimes.getBBox()
        if (repTimesBox.width > width) {
          let fillLine = elt('path', {
            d: `
              M ${width} ${(height) / 2}
              H ${repTimesBox.width + gp}
            `,
            fill: 'none',
            stroke: 'black',
            'stroke-width': '2',
          })
          g.appendChild(fillLine)
        }
      }

      let gBox = g.getBBox()
      return {
        g,
        width: gBox.width,
        height: gBox.height,
      }
    }
    function createRegularExpressionGraph(node) {


      let graph = createGraph(node.branches)
      let width = graph.width + 2 * gp
      let height = graph.height + 2 * gp
      let group = elt('rect', {
        width,
        height,
        fill: 'none',
      })
      let g = elt('g')
      g.appendChild(group)
      graph.g.setAttribute('transform', `translate(${gp}, ${gp})`)
      g.appendChild(graph.g)
      let startDot = elt('circle', {
        'cx': gp / 2,
        'cy': height / 2,
        r:gp / 2 - 1,
        fill: 'white',
        stroke: 'grey',
        'stroke-width': '2'
      })
      let endDot = elt('circle', {
        'cx': width - gp / 2,
        'cy': height / 2,
        r:gp / 2 - 1,
        fill: 'white',
        stroke: 'grey',
        'stroke-width': '2'
      })
      g.appendChild(startDot)
      g.appendChild(endDot)

      let gBox = g.getBBox()
      return {
        g,
        width: gBox.width,
        height: gBox.height,
      }
    }
  </script>
</html>
